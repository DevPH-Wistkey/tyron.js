(*
  Tyron: Decentralized identity application powered by Zilliqa
  Copyright (C) 2020 Julio Cesar Cabrapan Duarte

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
*)

scilla_version 0

(*************************)
(* The init.tyron library *)
(*************************)

library Init

  (* Messages *)
  (************)
  let one_msg =
    fun (msg: Message) =>
    let nil_msg = Nil {Message} in
    Cons {Message} msg nil_msg

  (* Constants *)
  (*************)
  let zero = Uint128 0
  
  (* Error events *)
  (****************)
  type Error =
    | CodeNotFoundation
    | CodeInsufficientFunds
    | CodeDomainTaken

  let make_error =
    fun (result : Error) =>
      let result_code = 
        match result with
          | CodeNotFoundation       => Int32 -1
          | CodeInsufficientFunds   => Int32 -2
          | CodeDomainTaken         => Int32 -3
        end
      in
      {_exception : "Error"; code : result_code}

(*********************************)
(* The init.tyron Smart-Contract *)
(*********************************)

contract Init(

(* Immutable fields declaration *)
(********************************)
  (* The address of the Tyron Pungtas Foundation *)
  foundationAddr: ByStr20,
  
  (* The contract's domain name, e.g. "did" *)
  domainName: String,
  
  (* The previously registered records *)
  initialRecords: Map String ByStr20
  )

(* Mutable fields declaration *)
(******************************)

  (* The DID-Smart-Contract code by version
  @key: version
  @value: Base64-encoded code *)
  field did_sc_code: Map String String = Emp String String
  
  (* The cost of each DID operation *)
  field operation_cost: Uint128 = zero
  
  (* The client's commission as a % of the operation_cost *)
  field client_commission: Uint128 = zero   
  
  (* The DNS records 
  @key: domain_name
  @value: address of the DID-SC *)
  field records: Map String ByStr20 = initialRecords
  
(* Procedures *)
(**************)

  (* The procedure to throw an error *)
  procedure ThrowError(
    err: Error
    )
      e = make_error err;
      throw e
  end

  (* Validates that the call comes from the foundation *)
  procedure IsFoundation()
      is_foundation = builtin eq foundationAddr _sender;
      match is_foundation with
        | True =>
        | False =>
            err = CodeNotFoundation;
            ThrowError err
      end
  end
  
  (* Executes the payment to the foundation *)
  procedure Payment()
      this_cost <- operation_cost;
      (* To be accepted, the payment MUST be exact *)
      payment_is_accepted = builtin eq _amount this_cost;
      match payment_is_accepted with
        | True =>
            (* The contract accepts the incoming transfer *)
            accept;
            msg_to_foundation = {
              _tag: "";
              _recipient: foundationAddr;
              _amount: _amount
            };
            msg = one_msg msg_to_foundation;
            send msg
        | False => 
            err = CodeInsufficientFunds;
            ThrowError err
      end
  end

(* Transitions *)
(***************)
  
  (* Sets the DID-Smart-Contract code *)
  transition SetDidCode(
    version: String,
    code: String
    )
      IsFoundation;
      did_sc_code[version] := code;
      e = {
        _eventname: "UpdatedTyronSmartContracts";
        did_sc_version: version;
        did_sc_code: code
      };
      event e
  end
  
  (* Sets the operation_cost *)
  transition OperationCost(
    cost: Uint128
    )
      IsFoundation;
      operation_cost := cost
  end
  
  (* Sets the client_commission *)
  transition ClientCommission(
    commission: Uint128
    )
      IsFoundation;
      client_commission := commission
  end
  
  (* Called by the DID-SC to set the operation_cost, foundation_address & client_commission *)
  transition Initialize()
      this_cost <- operation_cost;
      this_client_commission <- client_commission;
      msg_init = {
        _tag: "InitParameters";
        _recipient: _sender;
        _amount: zero;
        operationCost: this_cost;
        foundationAddress: foundationAddr;
        clientCommission: this_client_commission
      };
      init = one_msg msg_init;
      send init
  end
  
  (* Sets a domain in the DNS records *)
  transition SetDomain(
    domain: String
    )
      Payment;
      taken <- exists records[domain];
      match taken with
        | True =>
            err = CodeDomainTaken;
            ThrowError err
        | False =>
            records[domain] := _sender
      end
  end

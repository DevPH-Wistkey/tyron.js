(*
  Tyron: Decentralized identity application powered by Zilliqa
  Copyright (C) 2020 Julio Cesar Cabrapan Duarte

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
*)

scilla_version 0
import BoolUtils

(**************************)
(* The Tyron DIDC Library *)
(**************************)

library DIDC

(* Messages *)
(************)
  let one_msg = 
    fun(msg: Message) => 
    let nil_msg = Nil{Message} in
    Cons{Message} msg nil_msg

  let two_msgs =
    fun(msg1: Message) =>
    fun(msg2: Message) =>
      let msgs_tmp = one_msg msg2 in
      Cons{Message} msg1 msgs_tmp

(* The DidTrinity ADT *)
  type DidTrinity =
    | User              (* the contract owner *)
    | Tyron             (* the init.tyron contract *)
    | Client of String  (* the DID-Client with its tyron avatar *)

(* The Status ADTs *)
(*********************)
  type DidStatus =
    | Undefined
    | Initialized
    | Created
    | Updated
    | Recovered
    | Deactivated
  
  type CheckStatus =
    | NotDeactivated
    | Init
    | Operational   (* created, updated or recovered *)

(* The Service ADTs *)
(**********************)
  type DataTransferProtocol =
    | Https
    | Git
    | Ssh
    
  type ServiceEndpoint =
    | ServiceEndpoint of DataTransferProtocol String
    
  type DidService =
    | DidService of String ServiceEndpoint    (* the type & URI *)
    
(* Constants *)
(*************)
  let user = User
  let tyron = Tyron
  let notDeactivated = NotDeactivated
  let initialized = Init
  let operational = Operational
  let zero = Uint128 0
  let hundred = Uint128 100
  let undefined = "undefined"
  let deactivated = "deactivated"

(* Error events *)
(****************)
  type Error =
    | CodeNotTyron
    | CodeWrongAmount
    | CodeNotClient
    | CodeWrongStatus
    | CodeNotOwner
    | CodeWrongSignature
    | CodeUndefinedKey
    | CodeRepeatedKey
    | CodeNotDidToken
    | CodeNotProxy
      
  let make_error =
    fun(result: Error) =>
      let result_code = 
        match result with
          | CodeNotTyron              => Int32 -1
          | CodeWrongAmount           => Int32 -2
          | CodeNotClient             => Int32 -3
          | CodeWrongStatus           => Int32 -4
          | CodeNotOwner              => Int32 -5
          | CodeWrongSignature        => Int32 -6
          | CodeUndefinedKey          => Int32 -7
          | CodeRepeatedKey           => Int32 -8
          | CodeNotDidToken           => Int32 -9
          | CodeNotProxy              => Int32 -10
        end
      in
      {_exception: "Error"; code: result_code}

  let deconstruct_option_uint128 =
    fun(option: Option Uint128) =>
      match option with
        | Some value => value
        | _ => zero
      end

(***********************)
(* The xWallet Library *)
(***********************)
  type XDirection =
    | In
    | Out
  
  let incoming = In
  let outcoming = Out
  
(***************************************)
(* The Tyron DID-Smart-Contract (DIDC) *)
(***************************************)

contract DIDC(

(* Immutable fields declaration *)
(********************************)

  (* The user is the owner of their DIDC *)
  contractOwner: ByStr20,
  
  (* The address of the init.tyron contract *)
  initTyron: ByStr20
  )
      with
        let init = 0x5b166e13ed3ddbc450f9d8a599f8f09955e123a1 in
        builtin eq init initTyron
      =>

(* Mutable fields declaration *)
(******************************)

  (* The Tyron DID *)
  field decentralized_identifier: String = undefined
  
  (* The address of the init.tyron contract's latest implementation *)
  field init_tyron: ByStr20 = initTyron
  
  (* The user DID-Clients
   @key: client avatar
   @value: client address *)
  field did_clients: Map String ByStr20 = Emp String ByStr20
  field latest_client: ByStr20 = contractOwner
  
  (* The status of the DID *)
  field did_status: DidStatus = Undefined

  (* The Tyron verification methods
   @key: purpose
   @value: public key of type "SchnorrSecp256k1VerificationKey2019" *)
  field verification_methods: Map String ByStr33 = Emp String ByStr33
  
  (* The DID services
   @key: ID
   @value: DidService *)
  field services: Map String DidService = Emp String DidService
  
  (* The Tyron Hash *)
  field tyron_hash: Option ByStr = None{ByStr}

  (* The DID-Document in JSON format, hexadecimal encoded *)
  field did_document: Option ByStr = None{ByStr}
  
  (* The public key for the next DID-Update operation *)
  field did_update_key: Option ByStr33 = None{ByStr33}
  
  (* The public key for the next DID-Recover or DID-Deactivate operation *)
  field did_recovery_key: Option ByStr33 = None{ByStr33}
  
  
  (* The block number when the DID-Create operation occurred *)
  field created: BNum = BNum 0
  
  (* The block number when the last DID operation occurred *)  
  field ledger_time: BNum = BNum 0
  
  (* A monotonically increasing number representing the amount of DID operations that have taken place *)
  field transaction_number: Uint128 = Uint128 0

  (* The following fields are set by the init.tyron contract in the InitCallBack transition *)
      (* The cost of each DID operation *)
      field operation_cost: Uint128 = Uint128 0
      
      (* The address of the Tyron Pungtas Foundation *)
      field foundation_address: ByStr20 = contractOwner
      
      (* The client's commission as a % of the operation_cost, per client *)
      field client_commission: Map String Uint128 = Emp String Uint128
      field latest_commission: Uint128 = Uint128 0
  
  (* The xWallet fields *)
  field xWallet: Map ByStr20 String = Emp ByStr20 String
  field xBalances: Map String Uint128 = Emp String Uint128
  field xProxies: Map String ByStr20 = Emp String ByStr20

(**************)
(* Procedures *)
(**************)

(* The Tyron DID-Scheme - this procedure generates the user's Decentralized Identifier & the Tyron Hash *)
  procedure DidScheme()
      this_did =
        let did_prefix = "did:tyron:zil:test:" in
        let did_suffix = builtin to_string _this_address in
        builtin concat did_prefix did_suffix;
      decentralized_identifier := this_did;
      this_th =
        let hash = builtin sha256hash this_did in
        builtin to_bystr hash;
      th = Some{ByStr} this_th;
      tyron_hash := th
  end
  
(* The procedure to throw an error *)
  procedure ThrowError(
    err: Error
    )
      e = make_error err;
      throw e
  end
  
(* Validates that the order comes from a DidTrinity *)
  procedure IsRightCaller(
    caller: DidTrinity
    )
      match caller with
        | User =>
            is_owner = builtin eq contractOwner _sender;
            match is_owner with
              | True =>
              | False =>
                  err = CodeNotOwner;
                  ThrowError err
            end
        | Tyron =>
            this_tyron <- init_tyron;
            is_tyron = builtin eq this_tyron _sender;
            match is_tyron with
              | True =>
              | False =>
                  err = CodeNotTyron;
                  ThrowError err
            end
        | Client avatar =>
            this_client <- did_clients[avatar];
            match this_client with
              | Some client_address =>
                  latest_client := client_address;
                  commission <- client_commission[avatar];
                  this_client_commission = deconstruct_option_uint128 commission;
                  latest_commission := this_client_commission
              | None =>
                  err = CodeNotClient;
                  ThrowError err
            end
      end
  end

(* Verifies that the DID-Status is correct for the given operation *)
  procedure IsRightStatus(
    check: CheckStatus
    )
      this_status <- did_status;
      match check with
        | NotDeactivated =>
            match this_status with
              | Deactivated =>
                  err = CodeWrongStatus;
                  ThrowError err
              | _ =>
            end
        | Init =>
            match this_status with
              | Initialized =>
              | _ =>
                  err = CodeWrongStatus;
                  ThrowError err
            end
        | Operational =>
            match this_status with
              | Created =>
              | Updated =>
              | Recovered =>
              | _ =>
                  err = CodeWrongStatus;
                  ThrowError err
            end
      end
  end

(* Verifies that the public key matches the contract owner address *)
  procedure IsOwnerKey(
    pubk: ByStr33
    )
      hash = builtin sha256hash pubk;
      addr =
        let s = builtin to_string hash in
        let start = Uint32 26 in
        let len = Uint32 40 in
        builtin substr s start len;
      hex_addr =
        let hex = "0x" in
        builtin concat hex addr;
      addr_owner = builtin to_string contractOwner;
      is_owner = builtin eq hex_addr addr_owner;
      match is_owner with
        | True =>
        | False =>
            err = CodeNotOwner;
            ThrowError err
      end
  end
  
(* Verifies the Schnorr signature that comes with the signedData corresponds with the public DID-Keys stored in the contract *)
  procedure IsRightSignature(
    signedData: ByStr,
    sig: ByStr64,
    key: Option ByStr33
    )
      match key with
        | Some pubk =>
            signature_is_right = builtin schnorr_verify pubk signedData sig;
            match signature_is_right with
              | True => (* continue *)
              | False =>
                  err = CodeWrongSignature;
                  ThrowError err
            end
        | None =>
            err = CodeUndefinedKey;
            ThrowError err
      end
  end
  
(* Validates that the new public DID-Key is different from before *)
  procedure IsValidKey(
    didKey: Option ByStr33,
    key: ByStr33
    )
    match didKey with
      | Some pubk =>
          is_same_key = builtin eq pubk key;
          match is_same_key with
            | True =>
                err = CodeRepeatedKey;
                ThrowError err
            | False => (* continue *)
          end
      | None =>
          err = CodeUndefinedKey;
          ThrowError err
    end
  end
  
(* Executes the payment to the client and foundation *)
  procedure Payment(
    clientAvatar: String
    )
      client = Client clientAvatar;
      IsRightCaller client;
      this_cost <- operation_cost;
      (* To be accepted, the payment MUST be exact *)
      amount_is_correct = builtin eq _amount this_cost;
      match amount_is_correct with
        | True =>
            (* The DIDC accepts the incoming transfer *)
            accept;
            client_address <- latest_client;
            (* Calculates payment to the client *)
            this_client_commission <- latest_commission;
            payment_to_client =
              let percent = builtin div _amount hundred in
              builtin mul this_client_commission percent;
            msg_to_client = {
              _tag: "";
              _recipient: client_address;
              _amount: payment_to_client
            };
            e = {
              _eventname: "ClientPaymentVerified";
              client_avatar: clientAvatar;
              did_client: client_address;
              client_commission: this_client_commission
            };
            event e;
            (* Calculates payment to the foundation *)
            payment_to_foundation = builtin sub _amount payment_to_client;
            this_foundation_address <- foundation_address;
            msg_to_foundation = {
              _tag: "";
              _recipient: this_foundation_address;
              _amount: payment_to_foundation
            };
            (* Sends both payments at once *)
            msgs = two_msgs msg_to_client msg_to_foundation;
            send msgs
        | False => 
            err = CodeWrongAmount;
            ThrowError err
      end
  end
  
(* Generates a timestamp *)
  procedure Timestamp()
      this_block <- & BLOCKNUMBER;
      ledger_time := this_block;
      latest_tx_number <- transaction_number;
      new_tx_number =
        let incrementor = Uint128 1 in
        builtin add latest_tx_number incrementor;
      transaction_number := new_tx_number
  end

(***************)
(* Transitions *)
(***************)

(* Updates the init.tyron contract to its latest implementation - only the user aka contract owner can execute this transition *)
  transition UpdateInit(
    newInit: ByStr20
    )
      IsRightCaller user;
      init_tyron := newInit;
      e = {
        _eventname: "UpdatedInitTyron";
        new_init_tyron: newInit
      };
      event e
  end
(**)

(* Sets the DID-Client info into the user's DID account
 * Sends a message to the init.tyron contract that in return calls the InitParameters transition *)
  transition Init(
    clientAvatar: String
    )
      IsRightStatus notDeactivated;
      this_tyron <- init_tyron;
      msg_init = {
        _tag: "Initialize";
        _recipient: this_tyron;
        _amount: zero;
        client: clientAvatar
      };
      init = one_msg msg_init;
      send init
  end
  
(* The init.tyron contract calls this transition to set the operation_cost, foundation_address & client_commission *)
  transition InitCallBack(
    operationCost: Uint128,
    foundationAddress: ByStr20,
    clientAvatar: String,
    clientAddress: ByStr20,
    clientCommission: Uint128
    )
      IsRightCaller tyron;
      operation_cost := operationCost;
      foundation_address := foundationAddress;
      did_clients[clientAvatar] := clientAddress;
      client_commission[clientAvatar] := clientCommission;
      e = {
        _eventname: "DIDC init";
        did_client: clientAvatar;
        client_commission: clientCommission
      };
      event e;
      this_status <- did_status;
      match this_status with
        | Undefined =>
            new_status = Initialized;
            did_status := new_status
        | _ =>
      end
  end

(* Executes a Tyron DID-Create operation *)
  transition DidCreate(
    clientAvatar: String,
    document: ByStr,
    didContractOwner: ByStr33,
    signature: ByStr64,
    updateKey: ByStr33,
    recoveryKey: ByStr33
    )
      IsRightStatus initialized;
      Payment clientAvatar;
      IsRightCaller user;
      DidScheme;
      IsOwnerKey didContractOwner;
      did_contract_owner = Some{ByStr33} didContractOwner;
      IsRightSignature document signature did_contract_owner;
      first_doc = Some{ByStr} document;
      did_document := first_doc;
      IsValidKey did_contract_owner updateKey;
      update_key = Some{ByStr33} updateKey;
      did_update_key := update_key;
      IsValidKey did_contract_owner recoveryKey;
      recovery_key = Some{ByStr33} recoveryKey;
      did_recovery_key := recovery_key;
      is_same_key = builtin eq updateKey recoveryKey;
      match is_same_key with
        | True =>
            err = CodeRepeatedKey;
            ThrowError err
        | False =>
            new_status = Created;
            did_status := new_status;
            this_block <- & BLOCKNUMBER;
            created := this_block;
            Timestamp
      end
  end
  
(* Executes a Tyron DID-Recover operation *)
  transition DidRecover(
    clientAvatar: String,
    newDocument: ByStr,
    signature: ByStr64,
    newUpdateKey: ByStr33,
    newRecoveryKey: ByStr33
    )
      IsRightStatus operational;
      Payment clientAvatar;
      IsRightCaller user;
      did_key <- did_recovery_key;
      IsRightSignature newDocument signature did_key;
      new_doc = Some{ByStr} newDocument;
      did_document := new_doc;
      IsValidKey did_key newRecoveryKey;
      did_ukey <- did_update_key;
      IsValidKey did_ukey newRecoveryKey;
      next_recovery_key = Some{ByStr33} newRecoveryKey;
      did_recovery_key := next_recovery_key;
      IsValidKey did_key newUpdateKey;
      IsValidKey did_ukey newUpdateKey;
      next_update_key = Some{ByStr33} newUpdateKey;
      did_update_key := next_update_key;
      is_same_key = builtin eq newUpdateKey newRecoveryKey;
      match is_same_key with
        | True =>
            err = CodeRepeatedKey;
            ThrowError err
        | False =>
            new_status = Recovered;
            did_status := new_status;
            Timestamp
      end
  end
  
(* Executes a Tyron DID-Update operation *)
  transition DidUpdate(
    clientAvatar: String,
    newDocument: ByStr,
    signature: ByStr64,
    newUpdateKey: ByStr33
    )
      IsRightStatus operational;
      Payment clientAvatar;
      IsRightCaller user;
      did_key <- did_update_key;
      IsRightSignature newDocument signature did_key;
      new_doc = Some{ByStr} newDocument;
      did_document := new_doc;
      IsValidKey did_key newUpdateKey;
      did_rkey <- did_recovery_key;
      IsValidKey did_rkey newUpdateKey;
      next_update_key = Some{ByStr33} newUpdateKey;
      did_update_key := next_update_key;
      new_status = Updated;
      did_status := new_status;
      Timestamp
  end
  
(* Executes a Tyron DID-Deactivate operation *)
  transition DidDeactivate(
    clientAvatar: String,
    signature: ByStr64
    ) 
      IsRightStatus operational;
      Payment clientAvatar;
      IsRightCaller user;
      did_key <- did_recovery_key;
      this_th <- tyron_hash;
      match this_th with
        | Some th =>
            IsRightSignature th signature did_key
        | None =>
            err = CodeNotTyron;
            ThrowError err
      end;
      deactivated_doc = None{ByStr};
      did_document := deactivated_doc;
      deactivated_key = None{ByStr33};
      did_update_key := deactivated_key;
      did_recovery_key := deactivated_key;
      new_status = Deactivated;
      did_status := new_status;
      Timestamp
  end

(* Sets the user avatar.did for the Decentralized Identifier *)
  transition SetDomain(
    avatar: String
    )
      IsRightStatus operational;
      this_cost <- operation_cost;
      amount_is_correct = builtin eq _amount this_cost;
      match amount_is_correct with
        | True =>
            accept;
            msg = {
              _tag: "SetDomain";
              _recipient: initTyron;
              _amount: _amount;
              domain: avatar
            };
            msg_domain = one_msg msg;
            send msg_domain
        | False => 
            err = CodeWrongAmount;
            ThrowError err
      end
  end

(***********)
(* xWallet *)
(***********)
  
  procedure XWallet(
    direction: XDirection,
    amount: Uint128
    )
      optToken <- xWallet[_sender];
      match optToken with
        | Some token =>
            optBalance <-xBalances[token];
            balance = deconstruct_option_uint128 optBalance;
            match direction with
              | In =>
                  newBalance = builtin add balance amount;
                  xBalances[token] := newBalance
              | Out =>
                  newBalance = builtin sub balance amount;
                  xBalances[token] := newBalance
            end
        | None =>
            err = CodeNotDidToken;
            ThrowError err
      end
  end
  
  transition DidToken(
    token: String
    )
      IsRightStatus operational;
      IsRightCaller user;
      optToken_key <- verification_methods[token];
      match optToken_key with
        | Some token_key =>
            this_tyron <- init_tyron;
            msg = {
              _tag: "DidToken";
              _recipient: this_tyron;
              _amount: zero;
              avatar: token
            };
            updateToken = one_msg msg;
            send updateToken
        | None =>
            err = CodeNotDidToken;
            ThrowError err
      end
  end
  
(* The init.tyron contract calls this transition to update the DidToken *)
  transition DidTokenCallBack(
    token: String,
    proxyAddr: ByStr20,
    tokenAddr: ByStr20
    )
      IsRightCaller tyron;
      xWallet[tokenAddr] := token;
      xProxies[token] := proxyAddr;
      e = {
        _eventname: "DidToken Update";
        didToken: token;
        proxyAddr: proxyAddr;
        tokenAddr: tokenAddr
      };
      event e
  end
  
(* Adds native funds (ZIL) to the xWallet *)
  transition ZILIn()
      IsRightStatus operational;
      accept
  end
  
(* Sends ZIL from the xWallet to another xWallet (i.e. to another DIDC *)
  transition ZILOutToDid(
    to: ByStr20,
    amount: Uint128
    )
      IsRightStatus operational;
      IsRightCaller user;
      accept;
      msg = {
          _tag: "ZILIn";
          _recipient: to;
          _amount: amount
        };
      msg_did = one_msg msg;
      send msg_did
  end
  
(* Sends ZIL from the xWallet to a normal ZIL wallet *)
  transition ZILOutToZIL(
    to: ByStr20,
    amount: Uint128
    )
      IsRightStatus operational;
      IsRightCaller user;
      accept;
      msg = {
          _tag: "";
          _recipient: to;
          _amount: amount
        };
      msg_zil = one_msg msg;
      send msg_zil
  end

(* Acceptance transition - must be defined or transfers to this xWallet will fail otherwise *)
  transition RecipientAcceptTransfer(
    sender : ByStr20,
    recipient : ByStr20,
    amount : Uint128
    )
      IsRightStatus operational;
      XWallet incoming amount
  end

(* Transfers ZRC-2 verified tokens *)
  transition XTransfer(
    token: String,
    to: ByStr20,
    amount: Uint128,
    signature: ByStr64
    ) 
      IsRightStatus operational;
      IsRightCaller user;
      optBalance <- xBalances[token];
      balance = deconstruct_option_uint128 optBalance;
      is_enough = builtin lt amount balance;
      match is_enough with
        | True =>
            optToken_key <- verification_methods[token];
            signed_data =
              let hash = builtin sha256hash to in
              builtin to_bystr hash;
            IsRightSignature signed_data signature optToken_key;
            optProxy <- xProxies[token];
            match optProxy with
              | Some proxy =>
                  msg = {
                    _tag: "Transfer";
                    _recipient: proxy;
                    _amount: zero;
                    to: to;
                    amount: amount
                  };
                  xTransfer = one_msg msg;
                  send xTransfer
              | None =>
                  err = CodeNotProxy;
                  ThrowError err
            end
        | False =>
            err = CodeWrongAmount;
            ThrowError err
      end
  end
  
(* Callback transition - must be defined or transfers from this xWallet will fail otherwise *)
  transition TransferSuccessCallBack(
    sender: ByStr20, 
    recipient: ByStr20,
    amount : Uint128
    )
      IsRightStatus operational;
      XWallet outcoming amount
  end

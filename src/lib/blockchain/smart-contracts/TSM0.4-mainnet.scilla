(*
    TyronZIL-js: Decentralized identity client for the Zilliqa blockchain platform
    Copyright (C) 2020 Julio Cesar Cabrapan Duarte

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
*)

scilla_version 0

(*********************)
(* The tyron library *)
(*********************)

library Tyron
    (* Messages *)
    (************)
    let one_msg = 
        fun (msg: Message) => 
        let nil_msg = Nil { Message } in
        Cons { Message } msg nil_msg

    let two_msgs =
        fun (msg1: Message) =>
        fun (msg2: Message) =>
            let msgs_tmp = one_msg msg2 in
            Cons { Message } msg1 msgs_tmp

    (* Constants *)
    (*************)    
    let zero = Uint128 0
    let hundred = Uint128 100
    let create = "create"
    let update = "update"
    let recover = "recover"
    let deactivate = "deactivate"
    let undefined = "undefined"
  
    (* Error events *)
    (****************)
    type Error =
    | CodeNotTyron
    | CodeNotClient
    | CodeNotOwner
    | CodeWrongStatus
    | CodeWrongCommitment
    | CodeInsufficientFunds
    
    let make_error =
        fun (result : Error) =>
        let result_code = 
            match result with
            | CodeNotTyron              => Int32 -1
            | CodeNotClient             => Int32 -2
            | CodeNotOwner              => Int32 -3
            | CodeWrongStatus           => Int32 -4
            | CodeWrongCommitment       => Int32 -5
            | CodeInsufficientFunds     => Int32 -6
            end
        in
        { _exception : "Error"; code : result_code }

(****************************)
(* The tyron smart-contract *)
(****************************)

contract Tyron(
(* Immutable fields declaration *)
(********************************)
    tyron_init: ByStr20,        (* the address of the TyronInit contract *)
    contract_owner: ByStr20        (* the user is the owner of the contract *)
)
    with
        let init_contract = 0x1c8272a79b5b4920bcae80f310d638c8dd4bd8aa in
        builtin eq init_contract tyron_init
    =>

(* Mutable fields declaration *)
(******************************)
    field client_address: ByStr20 = 0xccDdFAD074cd608B6B43e14eb3440240f5bFf087
    
    (* defined by the TyronInit contract *)
    field operation_cost: Uint128 = Uint128 0   
    field foundation_address: ByStr20 = 0x45832badF26Bc3F66DA3b9eD242EA84AfFA024a3
    field client_commission: Uint128 = Uint128 0        (* % of the operation_cost *)       
    
    (* defined by the tyronZIL DID method specification *)
    field decentralized_identifier: String = ""
    field document: String = ""
    
    (* Sidetree public key commitments *)
    field update_commitment: String = ""
    field recovery_commitment: String = ""
    
    (* DID status & timestamp *)
    field status: String = ""
    field ledger_time: BNum = BNum 333
    field sidetree_transaction_number: Uint128 = Uint128 0 (* a monotonically increasing number *)
    
(* Procedures *)
(**************)

    procedure ThrowError(err: Error)
        e = make_error err;
        throw e
    end

    procedure IsTyron()
        did_tyron = builtin eq tyron_init _sender;
        match did_tyron with
        | True =>
        | False =>
            err = CodeNotTyron;
            ThrowError err
        end
    end

    procedure IsOwner()
        did_owner = builtin eq contract_owner _sender;
        match did_owner with
        | True =>
        | False =>
            err = CodeNotOwner;
            ThrowError err
        end
    end

    procedure IsClient()
        did_client <- client_address;
        is_client = builtin eq did_client _sender;
        match is_client with
        | True =>
        | False =>
            err = CodeNotClient;
            ThrowError err
        end
    end

    procedure IsStatus(
        thisStatus: String
    )
        did_status <- status;
        is_status = builtin eq did_status thisStatus;
        match is_status with
        | True =>
            err = CodeWrongStatus;
            ThrowError err
        | False =>
        end
    end

    procedure IsCommitment(        (* Checks the validity of a commitment *)
        thisCommitment: String,
        givenCommitment: String
    )
        commitment_is_correct = builtin eq thisCommitment givenCommitment;
        match commitment_is_correct with
        | True =>
        | False =>
            err = CodeWrongCommitment;
            ThrowError err
        end
    end

    procedure Payment()
        this_cost <- operation_cost;
        payment_is_accepted = builtin eq _amount this_cost;
        match payment_is_accepted with
        | True =>
            accept;
          (* Pays the tyron client and the foundation, must be externally owned addresses *)
            this_client_commission <- client_commission;
            payment_to_client = 
                let temp = builtin div _amount hundred in
                builtin mul temp this_client_commission;
            payment_to_foundation = builtin sub _amount payment_to_client;
            msg_to_client = {
                _tag: "";
                _recipient: _sender;
                _amount: payment_to_client
            };
            this_foundation_address <- foundation_address;
            msg_to_foundation = {
                _tag: "";
                _recipient: this_foundation_address;
                _amount: payment_to_foundation
            };
            msgs = two_msgs msg_to_client msg_to_foundation;
            send msgs
        | False => 
            err = CodeInsufficientFunds;
            ThrowError err
        end
    end
    
    procedure Timestamp()
        block <- & BLOCKNUMBER;
        ledger_time := block;
        latest_tx_number <- sidetree_transaction_number;
        new_tx_number =
            let incrementor = Uint128 1 in
            builtin add latest_tx_number incrementor;
        sidetree_transaction_number := new_tx_number
    end

(* Transitions *)
(***************)

    transition ContractInit(
      clientAddress: ByStr20
    )
        IsOwner;
        client_address := clientAddress;
        msg_init = {
            _tag: "Initialize";
            _recipient: tyron_init;
            _amount: zero
        };
        init = one_msg msg_init;
        send init
    end

    transition InitParameters(
        operationCost: Uint128,
        foundationAddress: ByStr20,
        clientCommission: Uint128
    )
        IsTyron;
        operation_cost := operationCost;
        foundation_address := foundationAddress;
        client_commission := clientCommission
    end

    transition DidCreate(
        didtyron: String,
        doc: String,
        updateCommitment: String,
        recoveryCommitment: String
    )
        IsClient;
        IsStatus create;
        IsStatus deactivate;
        Payment;
        decentralized_identifier := didtyron;
        document := doc;
        update_commitment := updateCommitment;
        recovery_commitment := recoveryCommitment;
        status := create;
        Timestamp
    end

    transition DidUpdate(
        updateCommitment: String,
        newDoc: String,
        newUpdateCommitment: String       
    )
        IsClient;
        IsStatus deactivate;
        this_commitment <- update_commitment;
        IsCommitment this_commitment updateCommitment;
        Payment;
        document := newDoc;
        update_commitment := newUpdateCommitment;
        status := update;
        Timestamp
    end

    transition DidRecover(
        recoveryCommitment: String,
        newDoc: String,
        newUpdateCommitment: String,
        newRecoveryCommitment: String
    )
        IsClient;
        IsStatus deactivate;
        this_commitment <- recovery_commitment;
        IsCommitment this_commitment recoveryCommitment;
        Payment;
        document := newDoc;
        update_commitment := newUpdateCommitment;
        recovery_commitment := newRecoveryCommitment;
        status := recover;
        Timestamp
    end

    transition DidDeactivate(
        recoveryCommitment: String
    )
        IsClient;
        IsStatus deactivate;
        this_commitment <- recovery_commitment;
        IsCommitment this_commitment recoveryCommitment;
        Payment;
        document := undefined;
        update_commitment := undefined;
        recovery_commitment := undefined;
        status := deactivate;
        Timestamp
    end

    transition UpdateClient(newClientAddress: ByStr20)
        IsOwner;
        client_address := newClientAddress;
        e = {
            _eventname: "UpdatedClient";
            new_client_address: newClientAddress
        };
        event e
    end

(*
  TyronZIL: Decentralized identity application powered by the Zilliqa blockchain platform
  Copyright (C) 2020 Julio Cesar Cabrapan Duarte

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
*)

scilla_version 0

(****************************)
(* The Tyron DID-SC Library *)
(****************************)

library DID

  (* Messages *)
  (************)
  let one_msg = 
    fun(msg: Message) => 
    let nil_msg = Nil{Message} in
    Cons{Message} msg nil_msg

  let two_msgs =
    fun(msg1: Message) =>
    fun(msg2: Message) =>
      let msgs_tmp = one_msg msg2 in
      Cons{Message} msg1 msgs_tmp

  (* The DidStatus ADT *)
  type DidStatus =
    | Undefined
    | Initialized
    | Created
    | Updated
    | Recovered
    | Deactivated
  
  (* Constants *)
  (*************)    
  let zero = Uint128 0
  let hundred = Uint128 100
  let undefined = "undefined"
  let deactivated = "deactivated"
  
  (* Error events *)
  (****************)
type Error =
    | CodeNotTyron
    | CodeInsufficientFunds
    | CodeNotClient
    | CodeWrongStatus
    | CodeNotOwner
    | CodeWrongSignature
    | CodeUndefinedKey
    | CodeRepeatedKey
      
  let make_error =
    fun(result: Error) =>
      let result_code = 
        match result with
          | CodeNotTyron              => Int32 -1
          | CodeInsufficientFunds     => Int32 -2
          | CodeNotClient             => Int32 -3
          | CodeWrongStatus           => Int32 -4
          | CodeNotOwner              => Int32 -5
          | CodeWrongSignature        => Int32 -6
          | CodeUndefinedKey          => Int32 -7
          | CodeRepeatedKey           => Int32 -8
        end
      in
      {_exception: "Error"; code: result_code}

(*****************************************)
(* The Tyron DID-Smart-Contract (DID-SC) *)
(*****************************************)

contract DID(

(* Immutable fields declaration *)
(********************************)
  (* The user is the owner of their DID-SC *)
  contract_owner: ByStr20,
  (* The address of the init.tyron contract *)
  init_tyron: ByStr20
  )
    with
      let init_contract = 0x08392647c23115f1d027b9d2bbcc9f532b0f003a in
      builtin eq init_contract init_tyron
    =>

(* Mutable fields declaration *)
(******************************)
  (* The Tyron DID *)
  field decentralized_identifier: String = undefined
  
  (* The Tyron Hash *)
  field tyron_hash: Option ByStr = None{ByStr}
  
  (* The status of the DID *)
  field did_status: DidStatus = Undefined
  
  (* The DID-Document in JSON format, hexadecimal encoded *)
  field did_document: Option ByStr = None{ByStr}
  
  (* The public key for the next DID-Update operation *)
  field did_update_key: Option ByStr33 = None{ByStr33}
  
  (* The public key for the next DID-Recover or DID-Deactivate operation *)
  field did_recovery_key: Option ByStr33 = None{ByStr33}
  
  (* The address of the user's client *)
  field client_address: ByStr20 = contract_owner
  
  (* The block number when the DID-Create operation occurred *)
  field created: BNum = BNum 0
  
  (* The block number when the last DID operation occurred *)  
  field ledger_time: BNum = BNum 0
  
  (* A monotonically increasing number representing the amount of DID operations that have taken place *)
  field transaction_number: Uint128 = Uint128 0

  (* The following fields are determined by the init.tyron contract *)
  (* The cost of each DID operation *)
  field operation_cost: Uint128 = Uint128 0
  
  (* The address of the Tyron Pungtas Foundation *)
  field foundation_address: ByStr20 = contract_owner
  
  (* The client's commission as a % of the operation_cost *)
  field client_commission: Uint128 = Uint128 0

(* Procedures *)
(**************)

  (* The Tyron DID-Scheme - this procedure generates the user's Decentralized Identifier & the Tyron Hash *)
  procedure DidScheme()
      this_did =
        let did_prefix = "did:tyron:zil:test:" in
        let did_suffix = builtin to_string _this_address in
        builtin concat did_prefix did_suffix;
      decentralized_identifier := this_did;
      this_th =
        let hash = builtin sha256hash this_did in
        builtin to_bystr hash;
      th = Some{ByStr} this_th;
      tyron_hash := th
  end
  
  (* The procedure to throw an error *)
  procedure ThrowError(
    err: Error
    )
      e = make_error err;
      throw e
  end
  
  (* Validates that the call comes from the init.tyron contract *)
  procedure IsTyron()
      is_tyron = builtin eq init_tyron _sender;
      match is_tyron with
        | True =>
        | False =>
            err = CodeNotTyron;
            ThrowError err
      end
  end
  
  (* Validates that the call comes from the client *)
  procedure IsClient()
      this_client <- client_address;
      is_client = builtin eq this_client _sender;
      match is_client with
        | True =>
        | False =>
            err = CodeNotClient;
            ThrowError err
      end
  end
  
  (* Validates that the call comes from the user *)
  procedure IsOwner()
      is_owner = builtin eq contract_owner _sender;
      match is_owner with
        | True =>
        | False =>
            err = CodeNotOwner;
            ThrowError err
      end
  end
  
  (* Verifies that the public key matches the contract_owner address *)
  procedure IsOwnerKey(
    pubk: ByStr33
    )
      hash = builtin sha256hash pubk;
      addr =
        let s = builtin to_string hash in
        let start = Uint32 26 in
        let len = Uint32 40 in
        builtin substr s start len;
      hex_addr =
        let hex = "0x" in
        builtin concat hex addr;
      addr_owner = builtin to_string contract_owner;
      is_owner = builtin eq hex_addr addr_owner;
      match is_owner with
        | True =>
        | False =>
            err = CodeNotOwner;
            ThrowError err
      end
  end
  
  (* Verifies that the status is 'Initialized' - needed for the DID-Create operation *)
  procedure IsInitialized()
      this_status <- did_status;
      match this_status with
        | Initialized =>
        | _ =>
            err = CodeWrongStatus;
            ThrowError err
      end
  end
  
  (* Verifies that the did_status is neither Deactivated nor Initialized, to execute a DID-Update, Recover or Deactivate operation *)
  procedure IsRightStatus()
      this_status <- did_status;
      match this_status with
        | Created =>
        | Updated =>
        | Recovered =>
        | _ =>
            err = CodeWrongStatus;
            ThrowError err
      end
  end
  
  (* Verifies the Schnorr signature that comes with the signedData corresponds with the public DID-Keys stored in the contract *)
  procedure IsRightSignature(
    signedData: ByStr,
    sig: ByStr64,
    key: Option ByStr33
    )
      match key with
        | Some pubk =>
            signature_is_right = builtin schnorr_verify pubk signedData sig;
            match signature_is_right with
              | True => (* continue *)
              | False =>
                  err = CodeWrongSignature;
                  ThrowError err
            end
        | None =>
            err = CodeUndefinedKey;
            ThrowError err
      end
  end
  
  (* Validates that the new public DID-Key is different from before *)
  procedure IsValidKey(
    didKey: Option ByStr33,
    key: ByStr33
    )
    match didKey with
      | Some pubk =>
          is_same_key = builtin eq pubk key;
          match is_same_key with
            | True =>
                err = CodeRepeatedKey;
                ThrowError err
            | False => (* continue *)
          end
      | None =>
          err = CodeUndefinedKey;
          ThrowError err
    end
  end
  
  (* Executes the payment to the client and foundation *)
  procedure Payment()
      this_cost <- operation_cost;
      (* To be accepted, the payment MUST be exact *)
      payment_is_accepted = builtin eq _amount this_cost;
      match payment_is_accepted with
        | True =>
            (* The DID-SC accepts the incoming transfer *)
            accept;
            (* Calculates payment to the client *)
            this_client_commission <- client_commission;
            payment_to_client =
              let percent = builtin div _amount hundred in
              builtin mul this_client_commission percent;
            msg_to_client = {
              _tag: "";
              _recipient: _sender;
              _amount: payment_to_client
            };
            (* Calculates payment to the foundation *)
            payment_to_foundation = builtin sub _amount payment_to_client;
            this_foundation_address <- foundation_address;
            msg_to_foundation = {
              _tag: "";
              _recipient: this_foundation_address;
              _amount: payment_to_foundation
            };
            (* Sends both payments at once *)
            msgs = two_msgs msg_to_client msg_to_foundation;
            send msgs
        | False => 
            err = CodeInsufficientFunds;
            ThrowError err
      end
  end
  
  (* Generates a timestamp *)
  procedure Timestamp()
      this_block <- & BLOCKNUMBER;
      ledger_time := this_block;
      latest_tx_number <- transaction_number;
      new_tx_number =
        let incrementor = Uint128 1 in
        builtin add latest_tx_number incrementor;
      transaction_number := new_tx_number
  end

(* Transitions *)
(***************)
  
  (* Sets the address of the user's client - permissionless (anyone can be a client)
   * Sends a message to the init.tyron contract that in return calls the InitParameters transition *)
  transition ContractInit(
    clientAddress: ByStr20
    )
      client_address := clientAddress;
      msg_init = {
        _tag: "Initialize";
        _recipient: init_tyron;
        _amount: zero
      };
      init = one_msg msg_init;
      send init
  end
  
  (* The init.tyron contract calls this transition to set the operation_cost, foundation_address & client_commission *)
  transition InitParameters(
    operationCost: Uint128,
    foundationAddress: ByStr20,
    clientCommission: Uint128
    )
      IsTyron;
      operation_cost := operationCost;
      foundation_address := foundationAddress;
      client_commission := clientCommission;
      new_status = Initialized;
      did_status := new_status
  end

  (* Executes a Tyron DID-Create operation *)
  transition DidCreate(
    document: ByStr,
    didContractOwner: ByStr33,
    signature: ByStr64,
    updateKey: ByStr33,
    recoveryKey: ByStr33
    )
      Payment;
      IsClient;
      IsInitialized;
      DidScheme;
      IsOwnerKey didContractOwner;
      did_contract_owner = Some{ByStr33} didContractOwner;
      IsRightSignature document signature did_contract_owner;
      first_doc = Some{ByStr} document;
      did_document := first_doc;
      IsValidKey did_contract_owner updateKey;
      update_key = Some{ByStr33} updateKey;
      did_update_key := update_key;
      IsValidKey did_contract_owner recoveryKey;
      recovery_key = Some{ByStr33} recoveryKey;
      did_recovery_key := recovery_key;
      is_same_key = builtin eq updateKey recoveryKey;
      match is_same_key with
        | True =>
            err = CodeRepeatedKey;
            ThrowError err
        | False =>
            new_status = Created;
            did_status := new_status;
            this_block <- & BLOCKNUMBER;
            created := this_block;
            Timestamp
      end
  end
  
  (* Executes a Tyron DID-Recover operation *)
  transition DidRecover(
    newDocument: ByStr,
    signature: ByStr64,
    newUpdateKey: ByStr33,
    newRecoveryKey: ByStr33
    )
      Payment;
      IsClient;
      IsRightStatus;
      did_key <- did_recovery_key;
      IsRightSignature newDocument signature did_key;
      new_doc = Some{ByStr} newDocument;
      did_document := new_doc;
      IsValidKey did_key newRecoveryKey;
      did_ukey <- did_update_key;
      IsValidKey did_ukey newRecoveryKey;
      next_recovery_key = Some{ByStr33} newRecoveryKey;
      did_recovery_key := next_recovery_key;
      IsValidKey did_key newUpdateKey;
      IsValidKey did_ukey newUpdateKey;
      next_update_key = Some{ByStr33} newUpdateKey;
      did_update_key := next_update_key;
      is_same_key = builtin eq newUpdateKey newRecoveryKey;
      match is_same_key with
        | True =>
            err = CodeRepeatedKey;
            ThrowError err
        | False =>
            new_status = Recovered;
            did_status := new_status;
            Timestamp
      end
  end
  
  (* Executes a Tyron DID-Update operation *)
  transition DidUpdate(
    newDocument: ByStr,
    signature: ByStr64,
    newUpdateKey: ByStr33
    )
      Payment;
      IsClient;
      IsRightStatus;
      did_key <- did_update_key;
      IsRightSignature newDocument signature did_key;
      new_doc = Some{ByStr} newDocument;
      did_document := new_doc;
      IsValidKey did_key newUpdateKey;
      did_rkey <- did_recovery_key;
      IsValidKey did_rkey newUpdateKey;
      next_update_key = Some{ByStr33} newUpdateKey;
      did_update_key := next_update_key;
      new_status = Updated;
      did_status := new_status;
      Timestamp
  end
  
  (* Executes a Tyron DID-Deactivate operation *)
  transition DidDeactivate(
    signature: ByStr64
    )
      Payment;
      IsClient;
      IsRightStatus;
      did_key <- did_recovery_key;
      this_th <- tyron_hash;
      match this_th with
        | Some th =>
            IsRightSignature th signature did_key
        | None =>
            err = CodeNotTyron;
            ThrowError err
      end;
      deactivated_doc = None{ByStr};
      did_document := deactivated_doc;
      deactivated_key = None{ByStr33};
      did_update_key := deactivated_key;
      did_recovery_key := deactivated_key;
      new_status = Deactivated;
      did_status := new_status;
      Timestamp
  end

  (* Updates the user's client - only the contract_owner can execute this transition *)
  transition UpdateClient(
    newClientAddress: ByStr20
    )
      IsOwner;
      client_address := newClientAddress;
      e = {
        _eventname: "UpdatedClient";
        new_client_address: newClientAddress
      };
      event e
  end

/*
	tyron.js: SSI Protocol's JavaScript/TypeScipt library
	Self-Sovereign Identity Protocol.
	Copyright (C) Tyron Pungtas and its affiliates.

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.
*/


import { PatchModel, PatchAction, Action, DataTransferProtocol, DocumentElement, ServiceModel } from './models/document-model';
import { PrivateKeyModel, PublicKeyInput, PublicKeyModel } from './models/verification-method-models';
import { Cryptography, OperationKeyPairInput } from '../util/did-keys';
import ErrorCode from '../util/ErrorCode';
import TyronZIL from '../../blockchain/tyronzil';

/** Operation types */
export enum OperationType {
	Create = "Created",
	Recover = "Recovered",
	Update = "Updated",
	Deactivate = "Deactivated"
}

export class Sidetree {
	public static async processPatches( patches: PatchModel[] )
	: Promise<{ updateDocument: any[], privateKeys: PrivateKeyModel[] }> {
		let update_document: any[] = [];
		let private_keys: PrivateKeyModel[] = [];
		
		for( const patch of patches ) {
			switch ( patch.action ) {
				case PatchAction.AddKeys: 
					if( patch.keyInput !== undefined ) {
						await this.addKeys( patch.keyInput )
						.then( async new_keys => {
							for ( let key of new_keys.publicKeys ) {
								update_document.push(key);
							}
							for ( let key of new_keys.privateKeys ) {
								private_keys.push(key)
							}
						})
						.catch(err => { throw err })
					} else {
						throw new ErrorCode("Missing", "No key in AddKeys patch")
					}
					break;
				case PatchAction.RemoveKeys:
					if( patch.ids !== undefined ) {
						for( const id of patch.ids ) {
							const KEY: PublicKeyModel = {
								id: id
							};
							const doc_element = await TyronZIL.documentElement(
								DocumentElement.VerificationMethod,
								Action.Removing,
								KEY
							);
							update_document.push(doc_element);
						}
					}
					break;
				case PatchAction.AddServices: 
					if( patch.services !== undefined ) {
						for (let service of patch.services) {
							update_document.push(service)
						}
					} else {
						throw new ErrorCode("Missing", "No services given to add")
					}
					break;
				case PatchAction.RemoveServices:
					if( patch.ids !== undefined ) {
						for( const id of patch.ids ) {
							const SERVICE: ServiceModel = {
								id: id,
								type: "",
								transferProtocol: DataTransferProtocol.Https,
								uri: ""
							};
							const doc_element = await TyronZIL.documentElement(
								DocumentElement.Service,
								Action.Removing,
								undefined,
								SERVICE
							);
							update_document.push(doc_element);
						}
					} else {
						throw new ErrorCode("Missing", "No service ID given to remove")
					}
					break;
				default:
					throw new ErrorCode("CodeIncorrectPatchAction", "The chosen action is not valid");
			}
		}
		return {
			updateDocument: update_document,
			privateKeys: private_keys,
		}
	}

	private static async addKeys(input: PublicKeyInput[]): Promise<NewKeys> {
		const verification_methods = [];
		const private_keys = [];
		for(let i=0, t= input.length; i<t; ++i) {
			const key_input = input[i];

			/** To create the DID public key */
			const key_pair_input: OperationKeyPairInput = {
				id: key_input.id
			}
			
			// Creates the key pair:
			const [verification_method, private_key] = await Cryptography.operationKeyPair(key_pair_input);
			verification_methods.push(verification_method);
			private_keys.push(private_key);
		}
		const new_keys: NewKeys = {
			publicKeys: verification_methods,
			privateKeys: private_keys
		}
		return new_keys;
		}
}

/***            ** interfaces **            ***/

/** Keys generated by the DID-Update operation */
interface NewKeys {
	publicKeys: any[];
	privateKeys: PrivateKeyModel[];
}
